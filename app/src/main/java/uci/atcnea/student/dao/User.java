package uci.atcnea.student.dao;

import java.util.List;
import uci.atcnea.student.dao.DaoSession;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
/**
 * Entity mapped to table "USER".
 */
public class User extends main.model.User{

    private Long id;
    private Boolean enable;
    private String imagePath;
    /** Not-null value. */
    private String username;
    private String password;
    private String profileJson;
    private String createdAt;
    private String updatedAt;
    private Boolean savePassword;
    private long nomenclatorId;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient UserDao myDao;

    private Nomenclator nomenclator;
    private Long nomenclator__resolvedKey;

    private List<Resource> resource;
    private List<Task> task;
    private List<FileRecord> filerecord;
    private List<UserLesson> userLesson;

    public User() {
        super();
    }

    public User(Long id) {

        super();
        this.id = id;
    }

    public User(Long id, Boolean enable, String imagePath, String username, String password, String profileJson, String createdAt, String updatedAt, Boolean savePassword, long nomenclatorId) {
        super(username, password, profileJson, imagePath);
        this.id = id;
        this.enable = enable;
        this.imagePath = imagePath;
        this.username = username;
        this.password = password;
        this.profileJson = profileJson;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
        this.savePassword = savePassword;
        this.nomenclatorId = nomenclatorId;


    }
    public User( Boolean enable, String imagePath, String username, String password, String profileJson, String createdAt, String updatedAt, long nomenclatorId) {
        super(username, password, profileJson, imagePath);
        this.id = super.getIdentifier();
        this.enable = enable;
        this.imagePath = imagePath;
        this.username = username;
        this.password = password;
        this.profileJson = profileJson;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
        this.savePassword = false;
        this.nomenclatorId = nomenclatorId;

    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getUserDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Boolean getEnable() {
        return enable;
    }

    public void setEnable(Boolean enable) {
        this.enable = enable;
    }

    public String getImagePath() {
        return imagePath;
    }

    public void setImagePath(String imagePath) {
        this.imagePath = imagePath;
    }

    /** Not-null value. */
    public String getUsername() {
        return username;
    }

    /** Not-null value; ensure this value is available before it is saved to the database. */
    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getProfileJson() {
        return profileJson;
    }

    public void setProfileJson(String profileJson) {
        this.profileJson = profileJson;
    }

    public String getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(String createdAt) {
        this.createdAt = createdAt;
    }

    public String getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(String updatedAt) {
        this.updatedAt = updatedAt;
    }

    public Boolean getSavePassword() {
        return savePassword;
    }

    public void setSavePassword(Boolean savePassword) {
        this.savePassword = savePassword;
    }

    public long getNomenclatorId() {
        return nomenclatorId;
    }

    public void setNomenclatorId(long nomenclatorId) {
        this.nomenclatorId = nomenclatorId;
    }

    /** To-one relationship, resolved on first access. */
    public Nomenclator getNomenclator() {
        long __key = this.nomenclatorId;
        if (nomenclator__resolvedKey == null || !nomenclator__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            NomenclatorDao targetDao = daoSession.getNomenclatorDao();
            Nomenclator nomenclatorNew = targetDao.load(__key);
            synchronized (this) {
                nomenclator = nomenclatorNew;
            	nomenclator__resolvedKey = __key;
            }
        }
        return nomenclator;
    }

    public void setNomenclator(Nomenclator nomenclator) {
        if (nomenclator == null) {
            throw new DaoException("To-one property 'nomenclatorId' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.nomenclator = nomenclator;
            nomenclatorId = nomenclator.getId();
            nomenclator__resolvedKey = nomenclatorId;
        }
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<Resource> getResource() {
        if (resource == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            ResourceDao targetDao = daoSession.getResourceDao();
            List<Resource> resourceNew = targetDao._queryUser_Resource(id);
            synchronized (this) {
                if(resource == null) {
                    resource = resourceNew;
                }
            }
        }
        return resource;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetResource() {
        resource = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<Task> getTask() {
        if (task == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            TaskDao targetDao = daoSession.getTaskDao();
            List<Task> taskNew = targetDao._queryUser_Task(id);
            synchronized (this) {
                if(task == null) {
                    task = taskNew;
                }
            }
        }
        return task;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetTask() {
        task = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<FileRecord> getFilerecord() {
        if (filerecord == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            FileRecordDao targetDao = daoSession.getFileRecordDao();
            List<FileRecord> filerecordNew = targetDao._queryUser_Filerecord(id);
            synchronized (this) {
                if(filerecord == null) {
                    filerecord = filerecordNew;
                }
            }
        }
        return filerecord;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetFilerecord() {
        filerecord = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<UserLesson> getUserLesson() {
        if (userLesson == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            UserLessonDao targetDao = daoSession.getUserLessonDao();
            List<UserLesson> userLessonNew = targetDao._queryUser_UserLesson(id);
            synchronized (this) {
                if(userLesson == null) {
                    userLesson = userLessonNew;
                }
            }
        }
        return userLesson;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetUserLesson() {
        userLesson = null;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

}
